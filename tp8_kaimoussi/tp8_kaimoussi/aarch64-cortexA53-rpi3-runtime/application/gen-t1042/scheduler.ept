open Scheduler_data
open Externc

const tasks : task_attributes^ntasks =
    [{ period=5; capacity=2; deadline=5; first_start=0 },
     { period=7; capacity=2; deadline=7; first_start=0 }]


type select_acc = { tid : int; sdeadline : int }


(* Fonction auxiliaire pour sélectionner la tâche avec la deadline la plus proche (EDF) *)
fun select_aux_edf(ts:task_status; ta:task_attributes; tid:int; acc:select_acc) returns (acc_o:select_acc)
let
    acc_o =
        if (ts.status = Ready) and (ts.current_deadline < acc.sdeadline) then 
            { tid = tid; sdeadline = ts.current_deadline }
        else acc
tel


(* Sélectionner une seule tâche selon EDF (mono-cœur) *)
fun select_one_task(ts:task_status^ntasks) returns(selected:int)
var tmp : select_acc ;
let
    tmp = foldi<<ntasks>> select_aux_edf
        (ts,tasks,{ tid = ntasks; sdeadline = 2147483647 }) ; (* int_max *)
    selected = tmp.tid ;
tel



type aux_type = { sel_proc : int ; sel_deadline : int }


fun slp_aux_edf (sa:select_acc; proc:int; acc:aux_type) returns (o:aux_type)
let
    o = if acc.sel_deadline > sa.sdeadline then
        { sel_proc = proc ; sel_deadline = sa.sdeadline }
    else acc
tel


(* Sélectionner le processeur avec la deadline la plus grande (pour le remplacer) *)
fun select_largest_deadline(acc:select_acc^nproc) returns (lp:int)
var search_result : aux_type ;
let
    search_result =
        foldi<<nproc>> slp_aux_edf (acc,{ sel_proc = 0 ;
        sel_deadline=(acc[0]).sdeadline});
    lp = search_result.sel_proc ;
tel


(* Sélectionner les tâches pour multi-cœurs selon EDF *)
fun select_tasks (ts:task_status^ntasks) returns(selected:int^nproc)
var tmp : select_acc^nproc ;
let
    tmp = foldi<<ntasks>> select_aux_mc_edf
        (ts,tasks,{ tid = ntasks; sdeadline = 2147483647 }^nproc);
    selected = map<<nproc>> select_tid tmp ;
tel


(* Fonction auxiliaire pour sélection multi-cœurs EDF *)
fun select_aux_mc_edf(ts:task_status; ta:task_attributes; tid:int;
acc:select_acc^nproc) returns (acc_o:select_acc^nproc)
let
    lp = select_largest_deadline(acc);
    acc_o =
        if ts.status = Ready then
            if ts.current_deadline < (acc[>lp<]).sdeadline then
                [ acc with [lp] = { tid = tid ; sdeadline = ts.current_deadline } ]
            else acc
        else acc
tel

fun select_tid(s:select_acc) returns (o : int)
let
    o = s.tid ;
tel


fun update_aux(selected:int^nproc; tid:int; proc_id:int; proc_acc_in:int) returns (proc_acc_out:int)
let
    proc_acc_out = if proc_acc_in = nproc then
        if selected[>proc_id<] = tid then proc_id else nproc
    else proc_acc_in
tel


fun update_selected_mc(ts:task_status;selected:int^nproc;tid:int) returns (tso:task_status)
var proc_id : int ;
let
    proc_id = foldi<<nproc>> update_aux (selected,tid^nproc,nproc);
    tso = if proc_id = nproc then ts
    else {
        ({ ts with .status = Running })
        with .current_proc = proc_id }
tel

(* Fonction EDF multi-cœurs - remplace rate_monotonic_mc *)
fun earliest_deadline_first_mc(ts:task_status^ntasks) returns (tso:task_status^ntasks)
var selected : int^nproc;
let
    selected = select_tasks (ts) ;
    tso = mapi<<ntasks>> update_selected_mc (ts, selected^ntasks) ;
tel




fun complete(tsi:task_status; task_end:bool) returns (o:task_status)
let
    o = if task_end then

        { tsi with .status = Waiting; .left = 0 }
    else if tsi.status = Running then

        { tsi with .status = Ready; .left = tsi.left - 1 }
    else tsi
tel


fun extract_proc_aux(ts:task_status; proc_id:int; acc:int) returns (o:int)
let
    o = if ts.status = Running and ts.current_proc = proc_id then
        tid
    else acc
tel

fun extract_proc(ts:task_status^ntasks) returns (task_run:int^nproc)
let
    task_run = mapi<<nproc>> extract_proc_aux_map (ts, ntasks^nproc) ;
tel

fun extract_proc_aux_map(ts:task_status^ntasks; ntasks_arr:int^nproc; proc_id:int) returns (o:int)
let
    o = foldi<<ntasks>> extract_proc_aux (ts, proc_id^ntasks, ntasks_arr[>proc_id<]) ;
tel



fun start_inst(current_date:int;tsi:task_status;ta:task_attributes) returns (tso:task_status)
var c : bool ;
let
    c = (current_date-ta.first_start)%ta.period = 0 ;
    tso = merge c 
        (true ->
            { status = Ready;
                current_deadline = 
                    (current_date when c) + (ta.deadline when c);
                left = ta.capacity when c;
                current_proc = nproc } 
        (false -> tsi whenot c)
tel

fun check_deadline(current_date:int;tsi:task_status;tid:int) returns (tso:task_status)
var c: bool ;
let
    c = (tsi.status = Ready) 
        and (tsi.current_deadline = current_date) ;
    () = deadline_miss_log(current_date when c,tid when c) ;
    tso = if c then { tsi with .status = Waiting} else tsi ;
tel



node scheduler(task_end:bool^ntasks) returns (task_run:int^nproc)
var ss : scheduler_state ;
new_date : int ;
tmp1,tmp2,tmp3,tmp4: task_status^ntasks ;
let
    ss = init_state fby { current_date = new_date ; tasks = tmp4 };
    new_date = ss.current_date + 1 ; 
    tmp1 = map <<ntasks>> complete (ss.tasks,task_end) ; 
    tmp2 = mapi<<ntasks>> check_deadline (new_date^ntasks,tmp1);
    tmp3 = map <<ntasks>> start_inst (new_date^ntasks,tmp2,tasks);
    tmp4 = earliest_deadline_first_mc(tmp3) ;  (* Utilisation de EDF au lieu de RM *)
    task_run = extract_proc(tmp4) ; 
tel


